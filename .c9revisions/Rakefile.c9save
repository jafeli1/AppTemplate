{"ts":1349294068497,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"require 'fileutils'\nrequire 'net/http'\nrequire 'uri'\nrequire 'json'\n\nENABLE_JSLINT = ENV['ENABLE_JSLINT'] == 'true'\n\ntask :default => [:debug, :build]\n\ndesc \"Create an app with the provided name (and optional SDK version and rally server)\"\ntask :new, :app_name, :sdk_version, :server do |t, args|\n  args.with_defaults(:sdk_version => \"2.0p4\", :server => \"https://rally1.rallydev.com\")\n  Dir.chdir(Rake.original_dir)\n\n  server = set_https(args[:server])\n  puts \"Generating new #{args[:sdk_version]} App Development framework...\"\n  puts \"Server: #{server}\"\n\n  config = Rally::AppSdk::AppConfig.new(args.app_name, args.sdk_version, server)\n  Rally::AppSdk::AppTemplateBuilder.new(config).build\n\n  puts \"Finished!\"\n  puts\n  puts \"To build your app, edit App.js then run '$rake build'.\"\n  puts \"To deploy your app, edit deploy.json then run '$rake deploy'.\"\n  puts\n  puts \"* Note: deploy.json stores login credentials and will be ignored by git.\"\n  puts\nend\n\ndesc \"Build a deployable app which includes all JavaScript and CSS resources inline\"\ntask :build => [:jslint] do\n  puts \"Building App...\"\n  Dir.chdir(Rake.original_dir)\n  Rally::AppSdk::AppTemplateBuilder.new(get_config_from_file).build_app_html\nend\n\ndesc \"Build a debug version of the app, useful for local development\"\ntask :debug do\n  Dir.chdir(Rake.original_dir)\n  Rally::AppSdk::AppTemplateBuilder.new(get_config_from_file).build_app_html(true)\nend\n\ndesc \"Clean all generated output\"\ntask :clean do\n  Dir.chdir(Rake.original_dir)\n  remove_files Rally::AppSdk::AppTemplateBuilder.get_auto_generated_files\nend\n\ndesc \"Deploy an app to a Rally server\"\ntask :deploy => [\"deploy:app\"] do\nend\n\nnamespace \"deploy\" do\n  # wrapped with top-level 'deploy' target as a convenience\n  task :app => [\"rake:build\"] do\n    config = get_config_from_file\n    app_filename = Rally::AppSdk::AppTemplateBuilder::HTML\n    deployr = Rally::AppSdk::Deployr.new(config, app_filename)\n    deployr.deploy\n  end\n\n  desc \"Deploy a debug app to a Rally server\"\n  task :debug => [\"rake:debug\"] do\n    config = get_config_from_file\n    app_filename = Rally::AppSdk::AppTemplateBuilder::HTML_DEBUG\n    deployr = Rally::AppSdk::Deployr.new(config, app_filename)\n    deployr.deploy\n  end\n\n  desc \"Display deploy information\"\n  task :info do\n    config = get_config_from_file\n    app_filename = Rally::AppSdk::AppTemplateBuilder::HTML\n    deployr = Rally::AppSdk::Deployr.new(config, app_filename)\n    deployr.info\n  end\nend\n\ndesc \"Run jslint on all JavaScript files used by this app, can be enabled by setting ENABLE_JSLINT=true.\"\ntask :jslint do |t|\n  if ENABLE_JSLINT\n    Dir.chdir(Rake.original_dir)\n\n    config = get_config_from_file\n    files_to_run = config.javascript\n    options = {\n        \"browser\" => true,\n        \"predef\" => [\"Rally\", \"Ext\"],\n        \"nomen\" => false,\n        \"onevar\" => false,\n        \"plusplus\" => false\n    }\n    Rally::Jslint.run_jslint(files_to_run, options)\n  end\nend\n\nmodule Rally\n  module AppSdk\n\n    # Name: Deployr\n    # Description: Class responsible for deploying Your app to a Rally server.\n    #              Already deployed? Your page will just be updated with new app source.\n    #              For new apps, a new single-layout page with a panel will be created.\n    #              Simply enter connection details in the config file.\n    #\n    #              For convenience, you can specify the name of your Rally project in\n    #              the config file.  If that name is not unique, you must set the project OID\n    #              instead.  If both are specific, only the OID is used.  To find a project OID:\n    #              [Rally > Setup > Workspace & Projects > hover project link > copy link location]\n    #              eg. https://<server>/#/699319d/detail/project/699319 --> 699319 is the Project OID.\n    #\n    # Security: Connection & credential info should be safely located (chmod 600) in deploy.json.\n    #\n    # Config:\n    #         deploy.json\n    #         { \n    #          ...\n    #          \"server\": \"http://rally1.rallydev.com\"   # or another instance\n    #          \"username\": \"someone@domain.com\"         # rally login name\n    #          \"password\": \"S3cr3tS4uce\"                # rally login password\n    #          \"project\": \"Some Project\"                # [optional] conveninence to set project name to deploy to\n    #          \"projectOid\": \"123\"                      # id of the project to deploy new page (can omit if setting 'project')\n    #          \"pageOid.cached\": \"456\"                   # !internal! cached page reference generated on 1st deploy\n    #          \"panelOid.cached\": \"789\"                  # !internal! cached panel reference generated on 1st deploy\n    #         }\n    #\n    # Workflow Overview:\n    #\n    #         New App:\n    #          Login > Create Page > [Set Cache] > Set Layout > Add Empty Panel > Upload Content\n    #         Existing App:\n    #          Login > [Get Cache] > Upload Content\n    #\n    # Manual Testing: The following shell curl statements, developed as a prelude to this Class,\n    #                 provide an alternate example for (manual) testing.  The uri's, schemes, and\n    #                 params in this class were taken directly from the curl statements.  Note that\n    #                 cookies.txt file used to pass around the session info.\n    #\n    #         LOGIN\n    #          curl --location --cookie-jar cookies.txt --data-urlencode \"j_username=<user>\" --data-urlencode \"j_password=<passwd>\"\n    #               https://demo01.rallydev.com/slm/platform/j_platform_security_check.op\n    #         CREATE BLANK PAGE\n    #           curl --cookie cookies.txt\n    #                --data \"name=foopage&type=DASHBOARD&timeboxFilter=none&pid=myhome&editorMode=create&cpoid=699319&projectScopeUp=false&projectScopeDown=false&version=0\"\n    #                \"https://demo01.rallydev.com/slm/wt/edit/create.sp\"\n    #         SET PAGE LAYOUT (SINGLE)\n    #           curl --cookie cookies.txt\n    #             \"https://demo01.rallydev.com/slm/dashboardSwitchLayout.sp?cpoid=699319&layout=SINGLE&dashboardName=myhome2246145&_slug=/custom/2246145\"\n    #         GET PANEL DEFINITION\n    #           curl --cookie cookies.txt\n    #                \"https://demo01.rallydev.com/slm/panel/getCatalogPanels.sp?cpoid=&ignorePanelDefOids&gesture=getcatalogpaneldefs&slug=/custom/2246145\"\n    #         CREATE PANEL\n    #           curl --location --cookie cookies.txt\n    #                --data \"panelDefinitionOid=739274&col=0&index=0&dashboardName=myhome224615\"\n    #                \"https://demo01.rallydev.com/slm/dashboard/addpanel.sp?cpoid=699319&_slug=/custom/2246145\"\n    #         UPLOAD PANEL CONTENT\n    #           curl --cookie cookies.txt\n    #             --data \"oid=2246150&dashboardName=myhome2246145&settings={'title':'my title','content':'my content'}\"\n    #             \"https://demo01.rallydev.com/slm/dashboard/changepanelsettings.sp?cpoid=699319&_slug=/custom/2246145\"\n    #\n    class Deployr\n\n      def initialize(config, app_filename)\n        @config = config                      # source of truth\n        @server = config.server\n        @port = \"443\"                         # SSL default port\n        @username = config.username\n        @password =config.password\n        @project_oid = config.project_oid     # id of project to deploy app to\n        @project = config.project             # [optional] name of project to deploy app to\n        @page_oid = config.page_oid           # id of existing page for updates\n        @panel_oid = config.panel_oid         # id of existing panel, on page, for updates\n        @tab_name = 'myhome'                  # internal name for 'My Home' application tab (used in http requests)\n        @tab_display_name = 'MyHome'          # display name 'My Home' application tab\n        @app_name = config.name               # user provided name for their app\n        @app_filename = app_filename          # locally built app\n        @session_cookie = nil                 # required during all server communication; defined after login\n      end\n\n      def deploy\n        puts \"Deploying to Rally...\"\n\n        login  # obtains session info\n        resolve_project  # determine if using oid or name from config\n\n        puts \"* Server:   #{@server}\"\n        puts \"* Username: #{@username}\"\n        puts \"* Project:  #{@project}\"\n\n        if !page_exists?\n          create_page\n          puts \"> Created '#{@tab_display_name} > #{@app_name}'page\"\n        end\n\n        upload_app\n        puts \"> Uploaded code to '#{@app_name}' page\"\n\n        write_local_html_app\n        puts \"* Local Test File: #{Rally::AppSdk::AppTemplateBuilder::HTML_LOCAL}\"\n        puts \"* Remote Test URL:#{@server}/#/#{@project_oid}/custom/#{@page_oid}\"\n        puts \"Finished!\"\n      end\n\n      def info\n        login  # obtains session info\n        resolve_project  # determine if using oid or name from config\n\n        is_deployed = !@page_oid.nil?   # if page_oid is cached, then we have deployed\n\n        puts \"    Status: #{(is_deployed)? '* ': '* Not '}Deployed *\"\n        puts \"      Page: #{@server}/#/#{@project_oid}/custom/#{@page_oid}\" if is_deployed\n        puts \"    Server: #{@server}\"\n        puts \" Page Name: #{@app_name}\"\n        puts \"  Username: #{@username}\"\n        puts \"   Project: #{@project}\" if !@project.nil?\n        puts \"ProjectOid: #{@project_oid}\" if !@project_oid.nil?\n      end\n\n      private\n\n      # Login to Rally and obtain session id\n      # Developer note: After posting login creds, Rally immediately issues a 302 redirect\n      def login\n        form_data = {\"j_username\" => @username, \"j_password\" => @password}\n        response = rally_post(\"/slm/platform/j_platform_security_check.op\", form_data, true)\n        # essential for subsequent calls to rally to authenticate internally\n        @session_cookie = get_session_cookie(response)\n      end\n\n      # Determines if the app has already been uploaded to an existing page.\n      # When a page is first deployed, the oid is saved in the config file.  This oid is\n      # then used in subsequent deploys as a 'cached' value to simply update the page.  Even with\n      # a cached value, we do a sanity check to verify the page _really_ exists.\n      #\n      # Developer Note:\n      #   * direct 'page' url format: https://demo01.rallydev.com/#/{project_oid}/custom/{dashboard_oid}\n      #                               https://demo01.rallydev.com/#/699319/custom/2248290\n      def page_exists?\n        # not cached\n        return false if @page_oid.nil?\n\n        # even cached, lets verify page still exists\n        response = rally_get(\"/#/#{@project_oid}/custom/#{@page_oid}\")\n        return true if response.class == Net::HTTPOK\n\n        # cached page that DNE means user deleted it; lets just create again\n        return false\n      end\n\n      def create_page\n        # new page with no panels\n        @page_oid = create_blank_page\n        @config.add_persistent_deploy_property(\"pageOid.cached\", @page_oid) # cache page oid for subsequent deploys\n\n        # set 'single' layout\n        set_page_layout\n\n        # container on page for app code\n        @panel_oid = create_empty_panel\n        @config.add_persistent_deploy_property(\"panelOid.cached\", @panel_oid)  # cache panel oid for subsequent deploys\n      end\n\n      # Extract Rally session cookie from response\n      def get_session_cookie(response)\n        response.get_fields('set-cookie').each do |cookie|\n          return cookie if cookie =~ /JSESSIONID/\n        end\n      end\n\n      # Create new page.\n      # Developer Note: After creating a page, the oid of the page is in the resulting html.\n      #                 We need this oid for future reference to the page.  Since html != xml,\n      #                 regex to the rexue.  While this is a lava pit in general, the match\n      #                 string needed is specific.   Also prevented gems e.g. nokogiri, etc.\n      def create_blank_page\n        form_data = {\"name\" => @app_name,\n                     \"type\" => 'DASHBOARD',\n                     \"timeboxFilter\" => \"none\",\n                     \"pid\" => @tab_name,\n                     \"editorMode\" => \"create\",\n                     \"cpoid\" => @project_oid,\n                     \"version\" => 0}\n        response = rally_post(\"/slm/wt/edit/create.sp\", form_data)\n\n        # Looking for page OID html element e.g. <input type=\"hidden\" name=\"oid\" value=\"2247529\"/>\n        match_data = /<input\\ +type=\"hidden\"\\ +name=\"oid\"\\ +value=\"(\\d+)\"\\/>/.match(response.body)\n\n        # TODO: error handling if page Id not found\n        page_oid = match_data[1]\n\n        return page_oid\n\n      end\n\n      # Create empty panel to place app source code\n      def create_empty_panel\n\n          # Lookup panel meta\n          path = \"/slm/panel/getCatalogPanels.sp\"\n          params = {:cpoid => @project_oid,\n                    :_slug => \"/custom/#{@page_oid}\",\n                    :ignorePanelDefOids => ''}  # empty ignorePanelDefOids apparently is required\n          response = rally_get(path, params)\n\n          panels = JSON.parse(response.body)\n          custom_html_panel_oid = nil\n          panels.each do |panel|\n            custom_html_panel_oid = panel['oid'] if panel['title'] == \"Custom HTML\"\n          end\n          \n          # Create new panel\n          request_path = \"/slm/dashboard/addpanel.sp\"\n          params = {:cpoid => @project_oid, :_slug => \"/custom/#{@page_oid}\"}\n          path = construct_get(request_path, params)\n\n          form_data = {\"panelDefinitionOid\" => custom_html_panel_oid,\n                       \"dashboardName\" => \"#{@tab_name}#{@page_oid}\",\n                       \"col\" => 0,\n                       \"index\" => 0}\n          response = rally_post(path, form_data)\n\n          # response is json that just contains oid e.g. {\"oid\": \"1234556\"}\n          panel_oid = JSON.parse(response.body)['oid']\n\n          return panel_oid\n      end\n\n      # Uploads application source\n      def upload_app\n          request_path = \"/slm/dashboard/changepanelsettings.sp\"\n          params = {:cpoid => @project_oid,\n                    :projectScopeUp => false,\n                    :projectScopeDown => true,\n                    :_slug => \"/custom/#{@page_oid}\"}\n          path = construct_get(request_path, params)\n\n          app_html = File.read(@app_filename)\n          panel_settings = {:title => @app_title, :content => app_html}\n\n          form_data = {\"oid\" => @panel_oid,\n                       \"dashboardName\" => \"#{@tab_name}#{@page_oid}\",\n                       \"settings\" => JSON.generate(panel_settings)}\n          response = rally_post(path, form_data)\n      end\n\n      # Set layout of page\n      def set_page_layout\n          path = \"/slm/dashboardSwitchLayout.sp\"\n          params = {:cpoid => @project_oid,\n                    :layout => \"SINGLE\",\n                    :dashboardName => \"#{@tab_name}#{@page_oid}\",\n                    :_slug => \"/custom/#{@page_oid}\",}\n          response = rally_get(path, params)\n      end\n\n      def write_local_html_app\n        filename = Rally::AppSdk::AppTemplateBuilder::HTML_LOCAL\n        app_width_default = 1024\n        scope_up = false\n        scope_down = false\n        content  = \"<!-- -------------------------------------------------------------- -->\\n\"\n        content += \"<!-- DO NOT EDIT: This file is auto-generated by rake 'deploy' task -->\\n\"\n        content += \"<!-- -------------------------------------------------------------- -->\\n\"\n        content += \"<!-- #{filename} makes it super fast to test the fully built app in a single panel -->\\n\"\n        content += \"<!-- without having to load the entire rally page.  Simply load #{filename} in -->\\n\"\n        content += \"<!-- a local browser to experience the speed! (e.g. file:///path/to/#{filename}) -->\\n\"\n        content += \"<html><body>\\n\"\n        content += \"<iframe width='100%' height='100%' frameborder='0'\\n\"\n        content += \"src='#{@server}/slm/panel/html.sp?width=#{app_width_default}&panelOid=#{@panel_oid}&cpoid=#{@project_oid}&projectScopeUp=#{scope_up}&projectScopeDown=#{scope_down}&isEditable=true'></iframe>\\n\"\n        content += \"</body></html>\"\n        File.open(filename, \"w\") { |file| file.write(content) }\n        puts \"> Created #{filename}\"\n      end\n\n      # Determine project reference (oid) either using a given oid or looking up a given project name (in config).\n      # This takes into consideration error handling for finding > 1 project with the same name.  Lets\n      # just assume that 80% of the time, project names are unique and it's handy to set in the config file.\n      # All others with conflicting names will just have to manually lookup the project oid and set in config file.\n      def resolve_project \n\n          # oid not given; lookup by name\n          if @project_oid.nil? || @project_oid.empty?\n\n            # no project settings (oid or name) found - error\n            if @project.nil? || @project.empty?\n              puts \"** Error: No project oid or name found in config file.\"\n              puts \"Exiting...\"\n              exit 1\n            end\n\n            # lookup oid for given name\n            path = \"/slm/webservice/1.36/project.js\"\n            params = {\"query\" => \"(Name%20%3D%20%22#{URI.encode(@project)}%22)\",\n                      \"fetch\" => \"ObjectID\"}\n            response = rally_get(path, params)\n            results = JSON.parse(response.body)\n            result_count = results[\"QueryResult\"][\"TotalResultCount\"].to_i\n\n           if result_count == 0\n             puts \"** Error: Unable to find '#{@project}' in Rally.  Check config file.\"\n             puts \"Exiting...\"\n             exit 1\n           elsif result_count > 1\n             puts \"** Error: Multiple projects named '#{@project}' found in Rally.  Set project_oid in config file.\"\n             puts \"Exiting...\"\n             exit 1\n           end\n\n            # grab project oid from single result in lookup\n            project_oid = results[\"QueryResult\"][\"Results\"][0][\"ObjectID\"]\n\n            # verify parsed project oid is all digits\n            if project_oid.to_s !~ /\\d+/ then\n              puts \"** Internal Error: Unable to parse project oid from name lookup.\"\n              puts \"** Debugging: There should be project info (e.g. 'ObjectID') in the results.\"\n              puts results[\"QueryResult\"][\"Results\"]\n              puts \"Exiting...\"\n              exit 1\n            end\n\n            @project_oid = project_oid\n\n          # oid given, lookup name\n          else\n            path = \"slm/webservice/1.36/project/#{@project_oid}.js\"\n            params = {\"fetch\" => \"Name\"}\n            response = rally_get(path, params)\n            results = JSON.parse(response.body)\n            @project = results[\"Project\"][\"Name\"]\n          end\n      end\n\n      # Utility to concatenate the GET request params after the given request path\n      # Given params={:foo => \"bar\", \"baz\" => \"quux\"} generate 'path?foo=bar?baz=quux'\n      def construct_get(path, params)\n          path = \"#{path}?\".concat(params.collect { |k,v| \"#{k}=#{v}\" }.join('&'))\n      end\n\n      # Perform HTTP GET to Rally with given uri path\n      def rally_get(path, params = {})\n\n        # format get params on end of path\n        path = construct_get(path, params) if !params.empty?\n        # ensure prepended slash\n        path = \"/#{path}\" if path[0] != '/'\n\n        uri = URI.parse(@server + \":\" + @port + path)\n        http = Net::HTTP.new(uri.host, uri.port)\n        http.use_ssl = true\n        http.verify_mode = OpenSSL::SSL::VERIFY_NONE\n        request = Net::HTTP::Get.new(uri.request_uri, {'Cookie' => \"#{@session_cookie}\"})\n        begin\n          response = http.request(request)\n          # bad username/password login; HTTPUnauthorized\n          raise \"Unauthorized access.  Check credentials in config file.\" if response.code == \"401\"\n        rescue Exception => e\n          puts \"** Error: Problem connecting to Rally server '#{@server}'.\"\n          puts \"** Reason: #{e.message}\"\n          puts \"Exiting...\"\n          exit 1\n        end\n        return response\n      end\n\n      # Perform HTTP POST to Rally with given uri path\n      def rally_post(path, form_data, login = false)\n        path = \"/#{path}\" if path[0] != '/'    # ensure prepended slash\n        uri = URI.parse(@server + \":\" + @port + path)\n\n        http = Net::HTTP.new(uri.host, uri.port)\n        http.use_ssl = true\n        http.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\n        headers = {'Cookie' => @session_cookie} unless login   # don't even have cookies until -after- login :)\n        request = Net::HTTP::Post.new(uri.request_uri, headers)\n        request.set_form_data(form_data)\n        begin\n          response = http.request(request)\n          # if session is bad (usually credentials) rally commonly responds with 302\n          raise \"Invalid session and/or credentials.  Check username/password in config file.\" if response.code == \"302\" && !login\n          # bad username/password login; HTTPUnauthorized\n          raise \"Unauthorized access.  Check credentials in config file.\" if response.code == \"401\"\n        rescue Exception => e\n          if login\n            puts \"** Error: Unable to login to Rally server '#{@server}'.\"\n          else\n            puts \"** Error: Problem connecting to Rally server '#{@server}'.\"\n          end\n          puts \"** Reason: #{e.message}\"\n          puts \"Exiting...\"\n          exit 1\n        end\n        return response\n      end\n\n    end\n\n    ## Builds the RallyJson config file as well as the JavaScript, CSS, and HTML\n    ## template files.\n    class AppTemplateBuilder\n\n      CONFIG_FILE = \"config.json\"\n      DEPLOY_FILE = \"deploy.json\"\n      GITIGNORE_FILE = \".gitignore\"\n      DEPLOY_DIR = 'deploy'\n      JAVASCRIPT_FILE = \"App.js\"\n      CSS_FILE = \"app.css\"\n      HTML = \"#{DEPLOY_DIR}/App.html\"\n      HTML_DEBUG = \"App-debug.html\"\n      HTML_LOCAL = \"App-local.html\"\n      CLASS_NAME = \"CustomApp\"\n\n      def self.get_auto_generated_files\n        [HTML, HTML_DEBUG]\n      end\n\n      def initialize(config)\n        @config = config\n      end\n\n      def build\n        fail_if_file_exists get_template_files\n\n        @config.javascript = JAVASCRIPT_FILE\n        @config.css = CSS_FILE\n        @config.class_name = CLASS_NAME\n\n        create_file_from_template CONFIG_FILE, Rally::AppTemplates::CONFIG_TPL\n        create_file_from_template DEPLOY_FILE, Rally::AppTemplates::DEPLOY_TPL\n        create_file_from_template GITIGNORE_FILE, Rally::AppTemplates::GITIGNORE_TPL\n        create_file_from_template JAVASCRIPT_FILE, Rally::AppTemplates::JAVASCRIPT_TPL, {:escape => true}\n        create_file_from_template CSS_FILE, Rally::AppTemplates::CSS_TPL\n      end\n\n      def build_app_html(debug = false, file = nil)\n        @config.validate\n\n        assure_deploy_directory_exists()\n\n        if file.nil?\n          file = debug ? HTML_DEBUG : HTML\n        end\n        template = debug ? Rally::AppTemplates::HTML_DEBUG_TPL : Rally::AppTemplates::HTML_TPL\n        template = populate_template_with_resources(template,\n                                                    \"JAVASCRIPT_BLOCK\",\n                                                    @config.javascript,\n                                                    debug,\n                                                    \"\\\"VALUE\\\"\",\n                                                    3)\n\n        template = populate_template_with_resources(template,\n                                                    \"STYLE_BLOCK\",\n                                                    @config.css,\n                                                    debug,\n                                                    \"<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"VALUE\\\">\",\n                                                    2)\n\n        create_file_from_template file, template, {:debug => debug, :escape => true}\n      end\n\n      def generate_js_inline_block\n        template = populate_template_with_resources(Rally::AppTemplates::JAVASCRIPT_INLINE_BLOCK_TPL, \"JAVASCRIPT_BLOCK\", @config.javascript, false, nil, 3)\n        replace_placeholder_variables template, {}\n      end\n\n      private\n\n      def assure_deploy_directory_exists\n        mkdir DEPLOY_DIR unless  File.exists?(DEPLOY_DIR)\n      end\n\n      def get_template_files\n        [CONFIG_FILE, DEPLOY_FILE, JAVASCRIPT_FILE, CSS_FILE, HTML_DEBUG, HTML_LOCAL]\n      end\n\n      def create_file_from_template(file, template, opts = {})\n        populated_template = replace_placeholder_variables template, opts\n        write_file file, populated_template\n      end\n\n      def write_file(path, content)\n        File.open(path, \"w\") { |file| file.write(content) }\n        puts \"> Created #{path}\"\n      end\n\n      def populate_template_with_resources(template, placeholder, resources, debug, debug_tpl, indent_level)\n        block = \"\"\n        indent_level = 1 if debug\n        indent = \"    \" * indent_level\n        separator = \"\"\n\n        resources.each do |file|\n          if debug\n            block << separator << debug_tpl.gsub(\"VALUE\"){file}\n            if is_javascript_file(file)\n              separator = \",\\n\" + indent * 4\n            else\n              separator = \"\\n\"\n            end\n          else\n            IO.readlines(file).each do |line|\n              block << indent << line.to_s.gsub(/\\\\'/, \"\\\\\\\\\\\\\\\\'\")\n            end\n          end\n        end\n        template.gsub(placeholder){block}\n      end\n\n      def replace_placeholder_variables(str, opts = {})\n        # by default, we will esacpe single quotes\n        escape = opts.has_key?(:escape) ? opts[:escape] : false\n        debug = opts.has_key?(:debug) ? opts[:debug] : false\n\n        str.gsub(\"APP_READABLE_NAME\", @config.name).\n            gsub(\"APP_NAME\", escape ? escape_single_quotes(@config.name) : @config.name).\n            gsub(\"APP_TITLE\", @config.name).\n            gsub(\"APP_SDK_VERSION\", @config.sdk_version).\n            gsub(\"APP_SERVER\", @config.server).\n            gsub(\"APP_SDK_PATH\", debug ? @config.sdk_debug_path : @config.sdk_path).\n            gsub(\"DEFAULT_APP_JS_FILE\", list_to_quoted_string(@config.javascript)).\n            gsub(\"DEFAULT_APP_CSS_FILE\", list_to_quoted_string(@config.css)).\n            gsub(\"CLASS_NAME\", @config.class_name)\n      end\n\n      def list_to_quoted_string(list)\n        \"\\\"#{list.join(\"\\\",\\\"\")}\\\"\"\n      end\n\n      def escape_single_quotes(string)\n        string.gsub(\"'\", \"\\\\\\\\\\\\\\\\'\")\n      end\n\n      def is_javascript_file(file)\n        file.split('.').last.eql? \"js\"\n      end\n    end\n\n\n    ## Simple object wrapping the configuration of an App\n    class AppConfig\n      SDK_FILE = \"sdk.js\"\n      SDK_DEBUG_FILE = \"sdk-debug.js\"\n\n      attr_reader :name, :sdk_version, :server\n      attr_accessor :javascript, :css, :class_name\n      attr_accessor :deploy_server, :username, :password, :project, :project_oid, :page_oid, :panel_oid\n\n      def self.from_config_file(config_file, deploy_file)\n        unless File.exist? config_file\n          raise Exception.new(\"Could not find #{config_file}.  Did you run 'rake new[\\\"App Name\\\"]'?\")\n        end\n\n        name = Rally::RallyJson.get(config_file, \"name\")\n        sdk_version = Rally::RallyJson.get(config_file, \"sdk\")\n        server = Rally::RallyJson.get(config_file, \"server\")\n        class_name = Rally::RallyJson.get(config_file, \"className\")\n        javascript = Rally::RallyJson.get_array(config_file, \"javascript\")\n        css = Rally::RallyJson.get_array(config_file, \"css\")\n\n        deploy_server = Rally::RallyJson.get(deploy_file, \"server\")\n        username = Rally::RallyJson.get(deploy_file, \"username\")\n        password = Rally::RallyJson.get(deploy_file, \"password\")\n        project_oid = Rally::RallyJson.get(deploy_file, \"projectOid\")\n        project = Rally::RallyJson.get(deploy_file, \"project\")\n        page_oid = Rally::RallyJson.get(deploy_file, \"pageOid.cached\")\n        panel_oid = Rally::RallyJson.get(deploy_file, \"panelOid.cached\")\n\n        config = Rally::AppSdk::AppConfig.new(name, sdk_version, server, config_file, deploy_file)\n        config.javascript = javascript\n        config.css = css\n        config.class_name = class_name\n        config.deploy_server = deploy_server\n        config.username = username\n        config.password = password\n        config.project_oid = project_oid\n        config.project = project\n        config.page_oid = page_oid\n        config.panel_oid = panel_oid\n        config\n      end\n\n      def initialize(name, sdk_version, server, config_file = nil, deploy_file = nil)\n        @name = sanitize_string name\n        @sdk_version = sdk_version\n        @server = server\n        @config_file = config_file\n        @deploy_file = deploy_file\n        @javascript = []\n        @css = []\n      end\n\n      def javascript=(file)\n        @javascript = (@javascript << file).flatten\n      end\n\n      def css=(file)\n        @css = (@css << file).flatten\n      end\n\n      # Add new name/value pair to the deploy config file\n      def add_persistent_deploy_property(name, value)\n        add_persistent_property(@deploy_file, name, value)\n      end\n\n      # Utility to add name/value pair to given config file\n      def add_persistent_property(file, name, value)\n        current_config = File.read(file)\n        rconfig = JSON.parse(current_config)\n        rconfig[name] = value\n        File.open(file, 'w') {|f| f.write(JSON.pretty_generate(rconfig))}\n      end\n\n      def validate\n        @javascript.each do |file|\n          raise Exception.new(\"Could not find JavaScript file #{file}\") unless File.exist? file\n        end\n\n        @css.each do |file|\n          raise Exception.new(\"Could not find CSS file #{file}\") unless File.exist? file\n        end\n\n        class_name_valid = false\n        @javascript.each do |file|\n          file_contents = File.open(file, \"rb\").read\n          if file_contents =~ /Ext.define\\(\\s*['\"]#{class_name}['\"]\\s*,/\n            class_name_valid = true\n            break\n          end\n        end\n        unless class_name_valid\n          msg = \"The 'className' property '#{class_name}' in #{Rally::AppSdk::AppTemplateBuilder::CONFIG_FILE} was not used when defining your app.\\n\" +\n              \"Please make sure that the 'className' property in #{Rally::AppSdk::AppTemplateBuilder::CONFIG_FILE} and the class name you use to define your app match!\"\n          raise Exception.new(msg)\n        end\n\n      end\n\n      def sdk_debug_path\n        \"#{@server}/apps/#{@sdk_version}/#{SDK_DEBUG_FILE}\"\n      end\n\n      def sdk_path\n        \"/apps/#{@sdk_version}/#{SDK_FILE}\"\n      end\n    end\n  end\n\n  class Jslint\n    def self.check_for_jslint_support\n      puts \"Running jslint...\"\n\n      begin\n        require 'rubygems'\n        require 'jslint-v8'\n      rescue Exception\n        puts \"In order to run jslint, you will need to install the 'jslint-v8' Ruby gem.\\n\" +\n                 \"You can do that by running:\\n\\tgem install jslint-v8\\n\"\n        false\n      end\n    end\n\n    def self.run_jslint(files_to_run, options)\n      return unless check_for_jslint_support\n\n      output_stream = STDOUT\n\n      formatter = JSLintV8::Formatter.new(output_stream)\n      runner = JSLintV8::Runner.new(files_to_run)\n      runner.jslint_options.merge!(options)\n\n\n      lint_result = runner.run do |file, errors|\n        formatter.tick(errors)\n      end\n\n      output_stream.print \"\\n\"\n      formatter.summary(files_to_run, lint_result)\n      raise \"Jslint failed\" unless lint_result.empty?\n    end\n  end\n\n  ## Pure (very simple) Ruby JSON implementation\n  module RallyJson\n    class << self\n\n      def get(file, key)\n        get_value(file, key)\n      end\n\n      def get_array(file, key)\n        get_array_values(file, key)\n      end\n\n      private\n      def get_value(file, key)\n        File.open(file, \"r\").each_line do |line|\n          if line =~ /^\\s*\"#{key}\"\\s*:\\s*\"(.*)\".*$/ || line =~ /^\\s*\"#{key}\"\\s*:\\s*(.*)\\s*$/\n            return $1\n          end\n        end\n        nil\n      end\n\n      def get_array_values(file, key)\n        values = []\n\n        in_block = false\n        File.open(file).each_line do |line|\n          in_block = true if line =~ /^\\s*\"#{key}\"\\s*:\\s*\\[/\n\n          if in_block\n            if line =~ /^\\s*\"#{key}\"\\s*:\\s*\\[(.*)\\]/\n              add_prop values, $1, key\n            elsif line =~ /^\\s*(\".*\")[,\\]]?/\n              add_prop values, $1, key\n            end\n          end\n\n          in_block = false if in_block && line =~ /.*\\][,]?/\n        end\n\n        values\n      end\n\n      def add_prop(array, values, exclude)\n        values.split(',').each do |value|\n          value = value.chomp.strip\n          value = value.chomp[1..(value.length-2)]\n          array << value unless value == exclude || value.nil?\n        end\n      end\n\n    end\n  end\n\n  module AppTemplates\n    ## Templates\n    JAVASCRIPT_TPL = <<-END\nExt.define('CLASS_NAME', {\n    extend: 'Rally.app.App',\n    componentCls: 'app',\n\n    launch: function() {\n        //Write app code here\n    }\n});\n    END\n\n    JAVASCRIPT_INLINE_BLOCK_TPL = <<-END\nJAVASCRIPT_BLOCK\n            Rally.launchApp('CLASS_NAME', {\n                name: 'APP_NAME'\n            });\n    END\n\n    HTML_DEBUG_TPL = <<-END\n<!DOCTYPE html>\n<html>\n<head>\n    <title>APP_TITLE</title>\n\n    <script type=\"text/javascript\" src=\"APP_SDK_PATH\"></script>\n\n    <script type=\"text/javascript\">\n        Rally.onReady(function() {\n            Rally.loadScripts([\n                JAVASCRIPT_BLOCK\n            ], function() {\n                Rally.launchApp('CLASS_NAME', {\n                    name: 'APP_NAME'\n                })\n            }, true);\n        });\n    </script>\n\nSTYLE_BLOCK\n</head>\n<body></body>\n</html>\n    END\n\n    HTML_TPL = <<-END\n<!DOCTYPE html>\n<html>\n<head>\n    <title>APP_TITLE</title>\n\n    <script type=\"text/javascript\" src=\"APP_SDK_PATH\"></script>\n\n    <script type=\"text/javascript\">\n        Rally.onReady(function() {\n#{JAVASCRIPT_INLINE_BLOCK_TPL}        });\n    </script>\n\n    <style type=\"text/css\">\nSTYLE_BLOCK    </style>\n</head>\n<body></body>\n</html>\n    END\n\n    CONFIG_TPL = <<-END\n{\n    \"name\": \"APP_READABLE_NAME\",\n    \"className\": \"CustomApp\",\n    \"server\": \"APP_SERVER\",\n    \"sdk\": \"APP_SDK_VERSION\",\n    \"javascript\": [\n        DEFAULT_APP_JS_FILE\n    ],\n    \"css\": [\n        DEFAULT_APP_CSS_FILE\n    ]\n}\n    END\n\n    DEPLOY_TPL = <<-END\n{\n    \"server\": \"APP_SERVER\",\n    \"username\": \"you@domain.com\",\n    \"password\": \"S3cr3t\",\n    \"project\": \"YourProject\"\n}\n    END\n\n    CSS_TPL = <<-END\n.app {\n     /* Add app styles here */\n}\n    END\n\n    GITIGNORE_TPL = <<-END\n# Ignore login credentials\n#{Rally::AppSdk::AppTemplateBuilder::DEPLOY_FILE}\n# Ignore debug build version of App\n#{Rally::AppSdk::AppTemplateBuilder::HTML_DEBUG}\n# Ignore 'local' build version of App\n#{Rally::AppSdk::AppTemplateBuilder::HTML_LOCAL}\n    END\n  end\nend\n\n## Helpers\ndef get_config_from_file\n  config_file = Rally::AppSdk::AppTemplateBuilder::CONFIG_FILE\n  deploy_file = Rally::AppSdk::AppTemplateBuilder::DEPLOY_FILE\n  Rally::AppSdk::AppConfig.from_config_file(config_file, deploy_file)\nend\n\ndef remove_files(files)\n  files.map { |f| File.delete(f) if File.exists?(f) }\nend\n\ndef fail_if_file_exists(files)\n  files.each do |file|\n    raise Exception.new \"I found an existing app file - #{file}.  If you want to create a new app, please remove this file!\" if File.exists? file\n  end\nend\n\ndef sanitize_string(value)\n  value.gsub(/[^a-zA-Z0-9 \\-_\\.']/, \"\")\nend\n\ndef set_https(uri)\n  prefix = 'https://'\n  if uri =~ /\\/\\//     # schema given; force ours\n    uri.gsub!(/^.*\\/\\//, prefix)\n  else                 # no schema given\n    uri = prefix + uri\n  end\n  uri\nend\n"]],"start1":0,"start2":0,"length1":0,"length2":35633}]],"length":35633}
